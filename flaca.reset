#!/bin/bash

# ------------------------------------------------------------------------------
# settings                                                              settings
# ------------------------------------------------------------------------------
set -o errtrace  # any trap on ERR is inherited by shell functions,
                 #   command substitutions, and commands executed in a subshell
                 #   environment
set -o nounset   # treat unset variables and parameters other than the special
                 #   parameters "@" and "*" as an error when performing
                 #   parameter expansion
set -o pipefail  # the return value of a pipeline is the value of the last
                 #   (rightmost) command to exit with a non-zero status, or
                 #   zero if all commands in the pipeline exit successfully

# set language
export LANG="en_US.UTF-8"

# use dot as decimal separator
export LC_NUMERIC="en_US.UTF-8"

# terminal colors
readonly    NONE=$(tput sgr0)
readonly     RED=$(tput setaf 1)
readonly   GREEN=$(tput setaf 2)
readonly  YELLOW=$(tput setaf 3)
readonly    BLUE=$(tput setaf 4)
readonly MAGENTA=$(tput setaf 5)
readonly    CYAN=$(tput setaf 6)
readonly   WHITE=$(tput setaf 7)

# set name of the file that holds the path of the current fashcard
readonly CFCFILE=".flaca.cfc"

# set fix box names
readonly FIRSTBOX="box000"
readonly LASTBOX="boxEND"

# ------------------------------------------------------------------------------
# functions                                                            functions
# ------------------------------------------------------------------------------

# -------
# failmsg
# -------
#
# This function prints a red colored message via stderr.
#
function failmsg()
{
  # push to stderr
  echo -e "${RED}[FAIL]${NONE} $1" 1>&2
}

# -------
# warnmsg
# -------
#
# This function prints a yellow colored message via stderr.
#
function warnmsg()
{
  # push to stderr
  echo -e "${YELLOW}[WARN]${NONE} $1" 1>&2
}

# -------
# infomsg
# -------
#
# This function prints a blue colored message via stderr.
#
function infomsg()
{
  # push to stderr
  echo -e "${BLUE}[INFO]${NONE} $1" 1>&2
}

# -------
# donemsg
# -------
#
# This function prints a green colored message via stderr.
#
function donemsg()
{
  # push to stderr
  echo -e "${GREEN}[DONE]${NONE} $1" 1>&2
}

# -------------------
# get_box_directories
# -------------------
#
# This function pushes all box directories to stdout,
# that are located in PWD. The names are sorted alphabetically.
#
function get_box_directories()
{
  find "$PWD"                      \
       -maxdepth  "1"              \
       -type      "d"              \
       -regextype "posix-extended" \
       -regex     ".+/box[^/]{3}$" \
       -printf    "%P\n"           \
  | sort
}

# -------------
# get_pdf_files
# -------------
#
# This function pushes all pdf files to stdout, that are located
# in the given directory. The names are sorted alphabetically.
#
# $1  directory
#
function get_pdf_files()
{
  find "$1"                           \
       -maxdepth  "1"                 \
       -type      "f"                 \
       -regextype "posix-extended"    \
       -regex     ".+\.[Pp][Dd][Ff]$" \
  | sort
}

# -----------------------
# get_number_of_pdf_files
# -----------------------
#
# This function pushes the number of pdf files to stdout,
# that are located in the given directory .
#
# $1  directory
#
function get_number_of_pdf_files()
{
  # get number of pdf files in this directory
  find "$1"                           \
       -maxdepth  "1"                 \
       -type      "f"                 \
       -regextype "posix-extended"    \
       -regex     ".+\.[Pp][Dd][Ff]$" \
       -printf    "."                 \
  | wc -c
}

# ---------------
# get_next_number
# ---------------
#
# This function pushes the next free counter to stdout,
# that can be used in the given directory.
#
# $1  directory
#
function get_next_number()
{
  {
    # push dummy file to stdout
    echo "000000-dummy.pdf"

    # get pdf files from this directory (print last part only)
    find "$1"                                                \
         -maxdepth  "1"                                      \
         -type      "f"                                      \
         -regextype "posix-extended"                         \
         -regex     ".+/[[:digit:]]{6}-[^/]+\.[Pp][Dd][Ff]$" \
         -printf    "%f\n"
  }                                                          \
  | sort                                                     \
  | tail -n 1                                                \
  | sed -re "s/^0*([[:digit:]]+)-.*/\1 + 1/"                 \
  | bc
}

# ---------------
# list_flashcards
# ---------------
#
#
#
function list_flashcards()
{
  # total number of flashcards
  local TOTAL=0

  # find box directories
  while read -r BOXDIR
  do

    # get number of flashcards in this box
    FNUM=$(get_number_of_pdf_files "$BOXDIR")

    # update total number
    (( TOTAL += FNUM ))

    # show number of flashcards in this box directory
    printf "  %s: %5d\n" "$BOXDIR" "$FNUM"

  done < <(get_box_directories)

  # show total number of flashcards
  printf "  %-6s: %5d\n" "total" "$TOTAL"

  # signalize success
  return 0
}

# ----------
# full_reset
# ----------
#
#
#
function full_reset()
{
  # show progress
  infomsg "creating temporary numbers"

  # initialize file counter
  local COUNTER=0

  # find all flashcards from box directories (lowest to highest)
  find -type      "f"                               \
       -regextype "posix-extended"                  \
       -regex     ".+/box[^/]{3}/.+\.[Pp][Dd][Ff]$" \
       -printf    "%P\n"                            \
  | sort                                            \
  | while read -r FLASHCARD
  do

    # step counter
    (( COUNTER += 1 ))

    # remove current counter
    local FIXPART=$(basename "$FLASHCARD" | sed -re "s/^[[:digit:]]{6}-//")

    # set new path
    local TARGETPATH=$(printf "%s/@%06d-%s" "$FIRSTBOX" "$COUNTER" "$FIXPART")

    # check if file already exists
    if [ -f "$TARGETPATH" ] ; then

      # notify user
      warnmsg "file already exists: \"$TARGETPATH\""

      # get hash value
      local HASH=$(sha1sum "$FLASHCARD" | sed -re "s/ .+//")

      # set new path
      local TARGETPATH=$(printf "%s/@%06d-%s-%s" ) "$FIRSTBOX" "$COUNTER" "$HASH" "$FIXPART"

      # check if file still exists
      if [ -f "$TARGETPATH" ] ; then

        # notify user
        failmsg "file already exists: \"$TARGETPATH\""

        # signalize trouble
        return 1

      fi

    fi

    # move flashcard to first box
    mv -f "$FLASHCARD" "$TARGETPATH" &>"/dev/null"

    # check operation
    if [ -f "$TARGETPATH" ] && [ ! -f "$FLASHCARD" ] ; then

      # show progress
      donemsg "$FLASHCARD --> $TARGETPATH"

    else

      # notify user
      failmsg "flashcard could not be moved: \"$FLASHCARD\""

      # signalize trouble
      return 1

    fi

  done

  # show progress
  infomsg "updating flashcard numbers"

  # second run: remove leading '@' characters
  while read -r FLASHCARD
  do

    # remove leading '@' character
    local FIXPART=$(basename "$FLASHCARD" | sed -nre "s/^@//p")

    # check if '@' character has been removed
    if [ -z "$FIXPART" ] ; then

      # next file
      continue

    fi

    # set new path
    local TARGETPATH=$(printf "%s/%s" "$FIRSTBOX" "$FIXPART")

    # rename flashcard
    mv -f "$FLASHCARD" "$TARGETPATH" &>"/dev/null"

    # check operation
    if [ -f "$FLASHCARD" ] || [ ! -f "$TARGETPATH" ] ; then

      # notify user
      failmsg "unable to rename file: \"$FLASHCARD\""

      # signalize trouble
      return 1

    else

      # show progress
      donemsg "$TARGETPATH <-- $FLASHCARD"

    fi

  done < <(get_pdf_files "$FIRSTBOX")

  # reset file that holds the path of the current flashcard
  truncate -s 0 "$CFCFILE"

  # signalize success
  return 0
}

# -------------
# partial_reset
# -------------
#
#
#
function partial_reset()
{
  # path of the previous box
  local PREVBOX=""

  # find all box directories (lowest to highest)
  while read -r BOXDIR
  do

    # check if previous box is defined
    if [ -n "$PREVBOX" ] ; then

      # get initial box index once
      local NEWNUM=$(get_next_number "$PREVBOX")

      # check index
      if [ -z "$NEWNUM" ] ; then

        # notify user
        failmsg "unable to resolve box index: \"$PREVBOX\""

        # signalize trouble
        return 1

      fi

      # move all flashcards to previous box
      while read -r FLASHCARD
      do

        # remove current box index
        local FIXPART=$(basename "$FLASHCARD" | sed -re "s/^[[:digit:]]{6}-//")

        # create target path
        local TARGETPATH=$(printf "%s/%06d-%s" "$PREVBOX" "$NEWNUM" "$FIXPART")

        # just to make sure not to clobber existing files
        if [ -f "$TARGETPATH" ] ; then

          # notify user
          failmsg "target file already exists: \"$TARGETPATH\""

          # signalize trouble
          return 1

        fi

        # move flashcard to previous box
        mv -f "$FLASHCARD" "$TARGETPATH" &>"/dev/null"

        # check operation
        if [ -f "$TARGETPATH" ] && [ ! -f "$FLASHCARD" ] ; then

          # show progress
          donemsg "$FIXPART: $PREVBOX <-- $BOXDIR"

        else

          # notify user
          failmsg "flashcard could not be moved: \"$FLASHCARD\""

          # signalize trouble
          return 1

        fi

        # step counter
        (( NEWNUM += 1 ))

      done < <(get_pdf_files "$BOXDIR")

    fi

    # update previous box
    local PREVBOX="$BOXDIR"

  done < <(get_box_directories)

  # signalize success
  return 0
}

# ------------------------------------------------------------------------------
# options                                                                options
# ------------------------------------------------------------------------------

# set default values
OPMODE="NOTHING"

# set options to accept
readonly KNOWN_OPTIONS=":hv01"

# check passed options
while getopts "$KNOWN_OPTIONS" OPTION "$@"
do

  case "$OPTION" in

    # full reset
    "0") OPMODE="FULL"
         ;;

    # partial reset
    "1") OPMODE="PARTIAL"
         ;;

    # show help
    "h") OPMODE="SHOW_HELP"
         ;;

    # show version
    "v") OPMODE="SHOW_VERSION"
         ;;

    "?") failmsg "unknown option: -$OPTARG"
         exit 1
         ;;

    ":") failmsg "missing argument: -$OPTARG <argument>"
         exit 1
         ;;

  esac

done

# get number of positional parameters
PPNUM=$(( $# - OPTIND + 1 ))

# drop all parsed options
shift $(( OPTIND - 1 ))

# ------------------------------------------------------------------------------
# commands                                                              commands
# ------------------------------------------------------------------------------

# check permission to write
if [ ! -w "$PWD" ] ; then

  # notify user
  failmsg "no permission to write here: \"$PWD\""

  # signalize trouble
  exit 1

fi

# check if first box is missing
if [ ! -d "$FIRSTBOX" ] ; then

  # notify user
  failmsg "unable to locate directory: \"$FIRSTBOX\""

  # signalize trouble
  exit 1

fi

# check if last box is missing
if [ ! -d "$LASTBOX" ] ; then

  # notify user
  failmsg "unable to locate directory: \"$LASTBOX\""

  # signalize trouble
  exit 1

fi

# list flashcards
if [ "$OPMODE" == "NOTHING" ] ; then

  echo
  echo "call  $(basename "$0") -0  to move all flashcards back to $FIRSTBOX"
  echo "call  $(basename "$0") -1  to move each fashcard back one box"
  echo

# move all flashcards back to FIRSTBOX
elif [ "$OPMODE" == "FULL" ] ; then

  full_reset

# move each flashcard back one box
elif [ "$OPMODE" == "PARTIAL" ] ; then

  # check if a flashcard is still active
  if [ -s "$CFCFILE" ] ; then

    # get path from 'current-flashcard' file
    FLASHCARD=$(sed -nre "/^[[:space:]]*$/ { d } ; p ; q" "$CFCFILE")

    # notify user
    warnmsg "move your active flashcard first: $FLASHCARD"

    # signalize trouble
    exit 1

  fi

  partial_reset

fi

# signalize success
exit 0

