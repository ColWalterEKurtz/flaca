#!/bin/bash

# ------------------------------------------------------------------------------
# settings                                                              settings
# ------------------------------------------------------------------------------
set -o errtrace  # any trap on ERR is inherited by shell functions,
                 #   command substitutions, and commands executed in a subshell
                 #   environment
set -o nounset   # treat unset variables and parameters other than the special
                 #   parameters "@" and "*" as an error when performing
                 #   parameter expansion
set -o pipefail  # the return value of a pipeline is the value of the last
                 #   (rightmost) command to exit with a non-zero status, or
                 #   zero if all commands in the pipeline exit successfully

# set language
export LANG="en_US.UTF-8"

# use dot as decimal separator
export LC_NUMERIC="en_US.UTF-8"

# terminal colors
readonly    NONE=$(tput sgr0)
readonly     RED=$(tput setaf 1)
readonly   GREEN=$(tput setaf 2)
readonly  YELLOW=$(tput setaf 3)
readonly    BLUE=$(tput setaf 4)
readonly MAGENTA=$(tput setaf 5)
readonly    CYAN=$(tput setaf 6)
readonly   WHITE=$(tput setaf 7)

# set name of the file that holds the path of the current fashcard
readonly CFCFILE=".flaca.cfc"

# set fix box names
readonly FIRSTBOX="box000"
readonly LASTBOX="boxEND"

# ------------------------------------------------------------------------------
# functions                                                            functions
# ------------------------------------------------------------------------------

# -------
# failmsg
# -------
#
# This function prints a red colored message via stderr.
#
function failmsg()
{
  # push to stderr
  echo -e "${RED}[FAIL]${NONE} $1" 1>&2
}

# -------
# warnmsg
# -------
#
# This function prints a yellow colored message via stderr.
#
function warnmsg()
{
  # push to stderr
  echo -e "${YELLOW}[WARN]${NONE} $1" 1>&2
}

# -------
# infomsg
# -------
#
# This function prints a blue colored message via stderr.
#
function infomsg()
{
  # push to stderr
  echo -e "${BLUE}[INFO]${NONE} $1" 1>&2
}

# -------
# donemsg
# -------
#
# This function prints a green colored message via stderr.
#
function donemsg()
{
  # push to stderr
  echo -e "${GREEN}[DONE]${NONE} $1" 1>&2
}

# -------
# get_box
# -------
#
# $1  flashcard path
#
function get_box()
{
  # get current box (last directory)
  sed -nre "s|.*(box[^/]{3})/[^/]+$|\1|p" <<< "$1"
}

# ------------------------------------------------------------------------------
# options                                                                options
# ------------------------------------------------------------------------------

# set default values
OPMODE="DRYRUN"

# set options to accept
readonly KNOWN_OPTIONS=":hvx"

# check passed options
while getopts "$KNOWN_OPTIONS" OPTION "$@"
do

  case "$OPTION" in

    # really move files
    "x") OPMODE="EXECUTE"
         ;;

    # show help
    "h") OPMODE="SHOW_HELP"
         ;;

    # show version
    "v") OPMODE="SHOW_VERSION"
         ;;

    "?") failmsg "unknown option: -$OPTARG"
         exit 1
         ;;

    ":") failmsg "missing argument: -$OPTARG <argument>"
         exit 1
         ;;

  esac

done

# get number of positional parameters
PPNUM=$(( $# - OPTIND + 1 ))

# drop all parsed options
shift $(( OPTIND - 1 ))

# ------------------------------------------------------------------------------
# commands                                                              commands
# ------------------------------------------------------------------------------

# check permission to write
if [ ! -w "$PWD" ] ; then

  # notify user
  failmsg "no permission to write here: \"$PWD\""

  # signalize trouble
  exit 1

fi

# check if first box is missing
if [ ! -d "$FIRSTBOX" ] ; then

  # notify user
  failmsg "unable to locate directory: \"$FIRSTBOX\""

  # signalize trouble
  exit 1

fi

# check if last box is missing
if [ ! -d "$LASTBOX" ] ; then

  # notify user
  failmsg "unable to locate directory: \"$LASTBOX\""

  # signalize trouble
  exit 1

fi

# initialize counter
COUNTER=0

# find all flashcards from box directories (lowest to highest)
find -type      "f"                               \
     -regextype "posix-extended"                  \
     -regex     ".+/box[^/]{3}/.+\.[Pp][Dd][Ff]$" \
     -printf    "%P\n"                            \
| sort                                            \
| while read -r FLASHCARD
do

  # step counter
  (( COUNTER += 1 ))

  # get current box
  NOWBOX=$(get_box "$FLASHCARD")

  # remove current counter
  FIXPART=$(basename "$FLASHCARD" | sed -re "s/^[[:digit:]]{6}-//")

  # set new path
  TARGETPATH=$(printf "%s/@%06d-%s" "$FIRSTBOX" "$COUNTER" "$FIXPART")

  # check if file already exists
  if [ -f "$TARGETPATH" ] ; then

    # notify user
    warnmsg "file already exists: \"$TARGETPATH\""

    # get hash value
    HASH=$(sha1sum "$FLASHCARD" | sed -re "s/ .+//")

    # set new path
    TARGETPATH=$(printf "%s/@%06d-%s-%s" ) "$FIRSTBOX" "$COUNTER" "$HASH" "$FIXPART"

    # check if file still exists
    if [ -f "$TARGETPATH" ] ; then

      # notify user
      failmsg "file already exists: \"$TARGETPATH\""

      # signalize trouble
      exit 1

    fi

  fi

  # check operation mode
  if [ "$OPMODE" == "EXECUTE" ] ; then

    # move flashcard to first box
    mv -f "$FLASHCARD" "$TARGETPATH" &>"/dev/null"

    # check operation
    if [ -f "$TARGETPATH" ] && [ ! -f "$FLASHCARD" ] ; then

      # show progress
      donemsg "$FIXPART: $FIRSTBOX <-- $NOWBOX"

    else

      # notify user
      failmsg "flashcard could not be moved: \"$FLASHCARD\""

      # signalize trouble
      return 1

    fi

  else

    # just show operation
    infomsg "$FIXPART: $FIRSTBOX <-- $NOWBOX"

  fi

done

# check operation mode
if [ "$OPMODE" == "EXECUTE" ] ; then

  # show progress
  infomsg "updating flashcard numbers"

  # second run: remove leading '@' characters
  find "$FIRSTBOX"                    \
       -maxdepth  "1"                 \
       -type      "f"                 \
       -regextype "posix-extended"    \
       -regex     ".+\.[Pp][Dd][Ff]$" \
  | sort                              \
  | while read -r FLASHCARD
  do

    # remove leading '@' character
    FIXPART=$(basename "$FLASHCARD" | sed -nre "s|^@||p")

    # check if '@' character has been removed
    if [ -z "$FIXPART" ] ; then

      # next file
      continue

    fi

    # set new path
    TARGETPATH=$(printf "%s/%s" "$FIRSTBOX" "$FIXPART")

    # rename flashcard
    mv -f "$FLASHCARD" "$TARGETPATH" &>"/dev/null"

    # check operation
    if [ -f "$FLASHCARD" ] || [ ! -f "$TARGETPATH" ] ; then

      # notify user
      failmsg "unable to rename file: \"$FLASHCARD\""

      # signalize trouble
      exit 1

    fi

  done

  # reset file that holds the path of the current flashcard
  truncate -s 0 "$CFCFILE"

else

  # notify user
  echo
  infomsg "this was a dry run: use -x option to move your files actually"
  echo

fi

# signalize success
exit 0

