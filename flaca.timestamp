#!/bin/bash

# ------------------------------------------------------------------------------
# settings                                                              settings
# ------------------------------------------------------------------------------
set -o errtrace  # any trap on ERR is inherited by shell functions,
                 #   command substitutions, and commands executed in a subshell
                 #   environment
set -o nounset   # treat unset variables and parameters other than the special
                 #   parameters "@" and "*" as an error when performing
                 #   parameter expansion
set -o pipefail  # the return value of a pipeline is the value of the last
                 #   (rightmost) command to exit with a non-zero status, or
                 #   zero if all commands in the pipeline exit successfully

# set language
export LANG="en_US.UTF-8"

# use dot as decimal separator
export LC_NUMERIC="en_US.UTF-8"

# terminal colors
readonly    NONE=$(tput sgr0)
readonly     RED=$(tput setaf 1)
readonly   GREEN=$(tput setaf 2)
readonly  YELLOW=$(tput setaf 3)
readonly    BLUE=$(tput setaf 4)
readonly MAGENTA=$(tput setaf 5)
readonly    CYAN=$(tput setaf 6)
readonly   WHITE=$(tput setaf 7)

# horizontal tabulator
readonly TAB="	"

# ------------------------------------------------------------------------------
# functions                                                            functions
# ------------------------------------------------------------------------------

# -------
# failmsg
# -------
#
# This function prints a red colored message via stderr.
#
function failmsg()
{
  # push to stderr
  echo -e "${RED}[FAIL]${NONE} $1" 1>&2
}

# -------
# warnmsg
# -------
#
# This function prints a yellow colored message via stderr.
#
function warnmsg()
{
  # push to stderr
  echo -e "${YELLOW}[WARN]${NONE} $1" 1>&2
}

# -------
# infomsg
# -------
#
# This function prints a blue colored message via stderr.
#
function infomsg()
{
  # push to stderr
  echo -e "${BLUE}[INFO]${NONE} $1" 1>&2
}

# -------
# donemsg
# -------
#
# This function prints a green colored message via stderr.
#
function donemsg()
{
  # push to stderr
  echo -e "${GREEN}[DONE]${NONE} $1" 1>&2
}

# -------------
# get_pdf_files
# -------------
#
# This function pushes all pdf files to stdout, that are
# located in PWD. The names are sorted alphabetically.
#
function get_pdf_files()
{
  find "$PWD"                               \
       -maxdepth  "1"                       \
       -type      "f"                       \
       -regextype "posix-extended"          \
       -regex     "[^$TAB]+\.[Pp][Dd][Ff]$" \
       -printf    "%P\n"                    \
  | sort
}

# ------------------------------------------------------------------------------
# options                                                                options
# ------------------------------------------------------------------------------

# set default values
OPMODE="ADD"

# set options to accept
readonly KNOWN_OPTIONS=":hvar"

# check passed options
while getopts "$KNOWN_OPTIONS" OPTION "$@"
do

  case "$OPTION" in

    # add initial timestamp if missing
    "a") OPMODE="ADD"
         ;;

    # remove timestamp if present
    "r") OPMODE="REMOVE"
         ;;

    # show help
    "h") OPMODE="SHOW_HELP"
         ;;

    # show version
    "v") OPMODE="SHOW_VERSION"
         ;;

    "?") failmsg "unknown option: -$OPTARG"
         exit 1
         ;;

    ":") failmsg "missing argument: -$OPTARG <argument>"
         exit 1
         ;;

  esac

done

# get number of positional parameters
PPNUM=$(( $# - OPTIND + 1 ))

# drop all parsed options
shift $(( OPTIND - 1 ))

# ------------------------------------------------------------------------------
# commands                                                              commands
# ------------------------------------------------------------------------------

# add initial timestamps
if [ "$OPMODE" == "ADD" ] ; then

  # get pdf files without timestamp
  get_pdf_files                                     \
  | sed -re "/^[[:digit:]]{12}-[[:digit:]]{12}-/ d" \
  | while read -r FILENAME
  do

    # set initial timestamps
    NEWNAME="000000000000-000000000000-$FILENAME"

    # check if file already exists
    if [ -f "$NEWNAME" ] ; then

      # notify user
      warnmsg "file already exists: \"$NEWNAME\""

      # next file
      continue

    fi

    # add initial timestamps
    mv -f "$FILENAME" "$NEWNAME" &>"/dev/null"

    # show progress
    infomsg "timestamp added: $FILENAME --> $NEWNAME"

  done

# remove existing timestamps
elif [ "$OPMODE" == "REMOVE" ] ; then

  # get pdf files with leading timestamp
  get_pdf_files                                                        \
  | sed -nre "s/^([[:digit:]]{12}-[[:digit:]]{12}-)(.+)$/\1\2$TAB\2/p" \
  | while read -r FILENAME NEWNAME
  do

    # check if file already exists
    if [ -f "$NEWNAME" ] ; then

      # notify user
      warnmsg "file already exists: \"$NEWNAME\""

      # next file
      continue

    fi

    # add initial timestamps
    mv -f "$FILENAME" "$NEWNAME" &>"/dev/null"

    # show progress
    infomsg "timestamp removed: $NEWNAME <-- $FILENAME"

  done

fi

# signalize success
exit 0

