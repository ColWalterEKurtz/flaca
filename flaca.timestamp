#!/bin/bash

# ------------------------------------------------------------------------------
# settings                                                              settings
# ------------------------------------------------------------------------------
set -o errtrace  # any trap on ERR is inherited by shell functions,
                 #   command substitutions, and commands executed in a subshell
                 #   environment
set -o nounset   # treat unset variables and parameters other than the special
                 #   parameters "@" and "*" as an error when performing
                 #   parameter expansion
set -o pipefail  # the return value of a pipeline is the value of the last
                 #   (rightmost) command to exit with a non-zero status, or
                 #   zero if all commands in the pipeline exit successfully

# set language
export LANG="en_US.UTF-8"

# use dot as decimal separator
export LC_NUMERIC="en_US.UTF-8"

# terminal colors
readonly    NONE=$(tput sgr0)
readonly     RED=$(tput setaf 1)
readonly   GREEN=$(tput setaf 2)
readonly  YELLOW=$(tput setaf 3)
readonly    BLUE=$(tput setaf 4)
readonly MAGENTA=$(tput setaf 5)
readonly    CYAN=$(tput setaf 6)
readonly   WHITE=$(tput setaf 7)

# horizontal tabulator
readonly TAB="	"

# ------------------------------------------------------------------------------
# functions                                                            functions
# ------------------------------------------------------------------------------

# -------
# failmsg
# -------
#
# This function prints a red colored message via stderr.
#
function failmsg()
{
  # push to stderr
  echo -e "${RED}[FAIL]${NONE} $1" 1>&2
}

# -------
# warnmsg
# -------
#
# This function prints a yellow colored message via stderr.
#
function warnmsg()
{
  # push to stderr
  echo -e "${YELLOW}[WARN]${NONE} $1" 1>&2
}

# -------
# infomsg
# -------
#
# This function prints a blue colored message via stderr.
#
function infomsg()
{
  # push to stderr
  echo -e "${BLUE}[INFO]${NONE} $1" 1>&2
}

# -------
# donemsg
# -------
#
# This function prints a green colored message via stderr.
#
function donemsg()
{
  # push to stderr
  echo -e "${GREEN}[DONE]${NONE} $1" 1>&2
}

# -------------
# get_pdf_files
# -------------
#
# This function pushes all pdf files to stdout, that are
# located in PWD. The names are sorted alphabetically.
#
function get_pdf_files()
{
  find "$PWD"                               \
       -maxdepth  "1"                       \
       -type      "f"                       \
       -regextype "posix-extended"          \
       -regex     "[^$TAB]+\.[Pp][Dd][Ff]$" \
       -printf    "%P\n"                    \
  | sort
}

# ----------------------
# show_second_difference
# ----------------------
#
# $1  from time (seconds)
# $2  to   time (seconds)
#
function show_second_difference()
{
  # set internal names
  local readonly FROMTIME="$1"
  local readonly TOTIME="$2"

  {
    echo "scale = 0"
    echo "if ($TOTIME < $FROMTIME) { -1 ; r = $FROMTIME - $TOTIME } else { 1 ; r = $TOTIME - $FROMTIME }"
    echo "d = r / 86400"
    echo "r = r % 86400"
    echo "h = r / 3600"
    echo "r = r % 3600"
    echo "m = r / 60"
    echo "s = r % 60"
    echo "d ; h ; m ; s"
  }                                    \
  | bc                                 \
  | sed -re "1{ s/-1/-/ ; s/1/+/ ; b}" \
  | xargs printf "%s %4dd %2dh %2dm %2ds\n"
}

# ------------------------------------------------------------------------------
# options                                                                options
# ------------------------------------------------------------------------------

# set default values
OPMODE="SHOW"

# set options to accept
readonly KNOWN_OPTIONS=":hvar"

# check passed options
while getopts "$KNOWN_OPTIONS" OPTION "$@"
do

  case "$OPTION" in

    # add initial timestamp if missing
    "a") OPMODE="ADD"
         ;;

    # remove timestamp if present
    "r") OPMODE="REMOVE"
         ;;

    # show help
    "h") OPMODE="SHOW_HELP"
         ;;

    # show version
    "v") OPMODE="SHOW_VERSION"
         ;;

    "?") failmsg "unknown option: -$OPTARG"
         exit 1
         ;;

    ":") failmsg "missing argument: -$OPTARG <argument>"
         exit 1
         ;;

  esac

done

# get number of positional parameters
PPNUM=$(( $# - OPTIND + 1 ))

# drop all parsed options
shift $(( OPTIND - 1 ))

# ------------------------------------------------------------------------------
# commands                                                              commands
# ------------------------------------------------------------------------------

# show duration to next query
if [ "$OPMODE" == "SHOW" ] ; then

  # sed abbreviations
  readonly SEDREG="^([[:digit:]]{12})-([[:digit:]]{12})-(.+)$"
  readonly SEDOUT="\1-\2-\3$TAB\1$TAB\2"

  # get current timestamp
  readonly NOW=$(date --utc "+%s")

  # find flashcards with real timestamps
  while read -r FILENAME QTIME HTIME
  do

    # skip new files first
    [ "$QTIME" == "000000000000" ] && continue

    # show time gap
    printf "%16s  %s\n" "$(show_second_difference "$NOW" "$QTIME")" "$FILENAME"

  done < <(get_pdf_files | sed -nre "s/$SEDREG/$SEDOUT/p")

# add initial timestamps
elif [ "$OPMODE" == "ADD" ] ; then

  # get pdf files without timestamp
  get_pdf_files                                     \
  | sed -re "/^[[:digit:]]{12}-[[:digit:]]{12}-/ d" \
  | while read -r FILENAME
  do

    # set initial timestamps
    NEWNAME="000000000000-000000000000-$FILENAME"

    # check if file already exists
    if [ -f "$NEWNAME" ] ; then

      # notify user
      warnmsg "file already exists: \"$NEWNAME\""

      # next file
      continue

    fi

    # add initial timestamps
    mv -f "$FILENAME" "$NEWNAME" &>"/dev/null"

    # show progress
    infomsg "timestamp added: $FILENAME --> $NEWNAME"

  done

# remove existing timestamps
elif [ "$OPMODE" == "REMOVE" ] ; then

  # get pdf files with leading timestamp
  get_pdf_files                                                        \
  | sed -nre "s/^([[:digit:]]{12}-[[:digit:]]{12}-)(.+)$/\1\2$TAB\2/p" \
  | while read -r FILENAME NEWNAME
  do

    # check if file already exists
    if [ -f "$NEWNAME" ] ; then

      # notify user
      warnmsg "file already exists: \"$NEWNAME\""

      # next file
      continue

    fi

    # add initial timestamps
    mv -f "$FILENAME" "$NEWNAME" &>"/dev/null"

    # show progress
    infomsg "timestamp removed: $NEWNAME <-- $FILENAME"

  done

fi

# signalize success
exit 0

