#!/bin/bash

# ------------------------------------------------------------------------------
# settings                                                              settings
# ------------------------------------------------------------------------------
set -o errtrace  # any trap on ERR is inherited by shell functions,
                 #   command substitutions, and commands executed in a subshell
                 #   environment
set -o nounset   # treat unset variables and parameters other than the special
                 #   parameters "@" and "*" as an error when performing
                 #   parameter expansion
set -o pipefail  # the return value of a pipeline is the value of the last
                 #   (rightmost) command to exit with a non-zero status, or
                 #   zero if all commands in the pipeline exit successfully

# set language
export LANG="en_US.UTF-8"

# use dot as decimal separator
export LC_NUMERIC="en_US.UTF-8"

# horizontal tabulator
readonly TAB="	"

# ------------------------------------------------------------------------------
# functions                                                            functions
# ------------------------------------------------------------------------------

# ------------------
# get_next_flashcard
# ------------------
#
#
#
function get_next_flashcard()
{
  # sed abbreviations
  local readonly SEDREG="^(0*)([[:digit:]]+)-(0*)([[:digit:]]+)-(.+)$"
  local readonly SEDOUT="\1\2-\3\4-\5$TAB\2$TAB\4"

  # get current timestamp
  local -i readonly NOW=$(date --utc "+%s")

  # initialize time values ('learn' and 'hit')
  local -i MINLTIME="999999999999"
  local -i MINHTIME="999999999999"
  
  # initialize path of newest expired flashcard
  local NEXTCARD=""

  # try to find expired flashcard with the smallest 'learn time' value
  while read -r FILENAME QTIME HTIME
  do

    # skip future flashcards
    (( QTIME > NOW )) && continue

    # calculate 'learn time'
    local -i LTIME=$(bc <<< "$QTIME - $HTIME")

    # find minumum LTIME
    if (( LTIME < MINLTIME )) ; then

      # update path
      local NEXTCARD="$FILENAME"

      # update time values
      local -i MINLTIME="$LTIME"
      local -i MINHTIME="$HTIME"

    # very unlikely case of two equal LTIME values
    elif (( LTIME == MINLTIME )) ; then

      # use older flashcard
      if (( HTIME < MINHTIME )) ; then

        # update path
        local NEXTCARD="$FILENAME"

        # update time values
        local -i MINLTIME="$LTIME"
        local -i MINHTIME="$HTIME"

      fi

    fi

  done < <(find "$PWD"                                                               \
                -maxdepth  "1"                                                       \
                -type      "f"                                                       \
                -regextype "posix-extended"                                          \
                -regex     ".+/[[:digit:]]{12}-[[:digit:]]{12}-[^/]+\.[Pp][Dd][Ff]$" \
                -printf    "%P\n"                                                    \
           | sed -nre "/^000000000000-000000000000/{ d } ; s/$SEDREG/$SEDOUT/p")

  # check if flashcard has been found
  if [ -n "$NEXTCARD" ] ; then

    # push path to stdout
    echo "$NEXTCARD"

    # signalize success
    return 0

  fi

  # try to find first totally new flashcard
  local NEXTCARD=$(find "$PWD"                                                         \
                        -maxdepth  "1"                                                 \
                        -type      "f"                                                 \
                        -regextype "posix-extended"                                    \
                        -regex     ".+/000000000000-000000000000-[^/]+\.[Pp][Dd][Ff]$" \
                        -printf    "%P\n"                                              \
                   | sort                                                              \
                   | head -n 1)

  # check if flashcard has been found
  if [ -n "$NEXTCARD" ] ; then

    # push path to stdout
    echo "$NEXTCARD"

    # signalize success
    return 0

  fi

  # no file found
  return 1
}

# ------------------------------------------------------------------------------
# commands                                                              commands
# ------------------------------------------------------------------------------

# check if there is still an active flashcard
ACTIVE=$(flaca.common get_active_flashcard)

# no (valid) flashcard found
if [ ! -f "$ACTIVE" ] ; then

  # try to get highest jamming flashcard
  ACTIVE=$(get_next_flashcard)

  # update active flashcard
  flaca.common set_active_flashcard "$ACTIVE"

  # no more jamming flashcards found
  if [ -z "$ACTIVE" ] ; then

    # notify user
    flaca.common donemsg "all flashcards seem to be learned"

    # stop here
    exit 1

  fi

fi

# show page 1 from ACTIVE flashcard
xreader -i 1 "$ACTIVE" &>"/dev/null" &

# signalize success
exit 0

