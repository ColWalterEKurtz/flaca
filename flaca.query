#!/bin/bash

# ------------------------------------------------------------------------------
# settings                                                              settings
# ------------------------------------------------------------------------------
set -o errtrace  # any trap on ERR is inherited by shell functions,
                 #   command substitutions, and commands executed in a subshell
                 #   environment
set -o nounset   # treat unset variables and parameters other than the special
                 #   parameters "@" and "*" as an error when performing
                 #   parameter expansion
set -o pipefail  # the return value of a pipeline is the value of the last
                 #   (rightmost) command to exit with a non-zero status, or
                 #   zero if all commands in the pipeline exit successfully

# set language
export LANG="en_US.UTF-8"

# use dot as decimal separator
export LC_NUMERIC="en_US.UTF-8"

# horizontal tabulator
readonly TAB="	"

# ------------------------------------------------------------------------------
# functions                                                            functions
# ------------------------------------------------------------------------------

# -------------
# get_pdf_files
# -------------
#
# This function pushes all pdf files to stdout, that are
# located in PWD. The names are sorted alphabetically.
#
function get_pdf_files()
{
  find "$PWD"                         \
       -maxdepth  "1"                 \
       -type      "f"                 \
       -regextype "posix-extended"    \
       -regex     ".+\.[Pp][Dd][Ff]$" \
       -printf    "%P\n"              \
  | sort
}

# ------------------
# get_next_flashcard
# ------------------
#
#
#
function get_next_flashcard()
{
  # sed abbreviations
  local readonly SEDREG="^([[:digit:]]{12})-([[:digit:]]{12})-(.+)$"
  local readonly SEDOUT="\1-\2-\3$TAB\1$TAB\2"

  # get current timestamp
  local readonly NOW=$(date --utc "+%s")

  # initialize path of newest expired flashcard
  local NEWESTEXPIRED=""

  # try to find newest expired flashcard
  while read -r FILENAME QTIME HTIME
  do

    # skip new files first
    [ "$QTIME" == "000000000000" ] && continue

    # remove leading zeros
    local QTIME_NUMERIC=$(sed -re "s/0*([[:digit:]]+)/\1/" <<< "$QTIME")

    # first future flashcard found
    (( QTIME_NUMERIC > NOW )) && break

    # update newest expired flashcard
    local NEWESTEXPIRED="$FILENAME"

  done < <(get_pdf_files | sed -nre "s/$SEDREG/$SEDOUT/p")

  # check if newest expired flashcard has been found
  if [ -n "$NEWESTEXPIRED" ] ; then

    # push path to stdout
    echo "$NEWESTEXPIRED"

    # signalize success
    return 0

  fi

  # try to find first totally new flashcard
  read -r FILENAME QTIME HTIME < <(get_pdf_files | sed -nre "s/$SEDREG/$SEDOUT/p" | head -n 1)

  # check if totally new flashcard has been found
  if [ "$QTIME" == "000000000000" ] ; then

    # push filename to stdout
    echo "$FILENAME"

    # signalize success
    return 0

  fi

  # no file found
  return 1
}

# -------------------
# get_next_flashcard2
# -------------------
#
#
#
function get_next_flashcard2()
{
  # sed abbreviations
  local readonly SEDREG="^(0*)([[:digit:]]+)-(0*)([[:digit:]]+)-(.+)$"
  local readonly SEDOUT="\1\2-\3\4-\5$TAB\2$TAB\4"

  # get current timestamp
  local readonly NOW=$(date --utc "+%s")

  # try to find expired flashcard
  while read -r FILENAME QTIME HTIME
  do

    # skip future flashcards
    (( QTIME > NOW )) && continue

    local LTIME=$(bc <<< "$QTIME - $HTIME")

    echo "$FILENAME"
    echo "$QTIME"
    echo "$HTIME"
    echo "$LTIME"
    echo

  done < <(find "$PWD"                                                               \
                -maxdepth  "1"                                                       \
                -type      "f"                                                       \
                -regextype "posix-extended"                                          \
                -regex     ".+/[[:digit:]]{12}-[[:digit:]]{12}-[^/]+\.[Pp][Dd][Ff]$" \
                -printf    "%P\n"                                                    \
           | sed -nre "/^000000000000-000000000000/{ d } ; s/$SEDREG/$SEDOUT/p")
}

# ------------------------------------------------------------------------------
# commands                                                              commands
# ------------------------------------------------------------------------------

get_next_flashcard2

exit 1

# check if there is still an active flashcard
ACTIVE=$(flaca.common get_active_flashcard)

# no (valid) flashcard found
if [ ! -f "$ACTIVE" ] ; then

  # try to get highest jamming flashcard
  ACTIVE=$(get_next_flashcard)

  # update active flashcard
  flaca.common set_active_flashcard "$ACTIVE"

  # no more jamming flashcards found
  if [ -z "$ACTIVE" ] ; then

    # notify user
    flaca.common donemsg "all flashcards seem to be learned"

    # stop here
    exit 1

  fi

fi

# show page 1 from ACTIVE flashcard
xreader -i 1 "$ACTIVE" &

# signalize success
exit 0

