#!/bin/bash

# ------------------------------------------------------------------------------
# settings                                                              settings
# ------------------------------------------------------------------------------
set -o errtrace  # any trap on ERR is inherited by shell functions,
                 #   command substitutions, and commands executed in a subshell
                 #   environment
set -o nounset   # treat unset variables and parameters other than the special
                 #   parameters "@" and "*" as an error when performing
                 #   parameter expansion
set -o pipefail  # the return value of a pipeline is the value of the last
                 #   (rightmost) command to exit with a non-zero status, or
                 #   zero if all commands in the pipeline exit successfully

# set language
export LANG="en_US.UTF-8"

# use dot as decimal separator
export LC_NUMERIC="en_US.UTF-8"

# terminal colors
readonly    NONE=$(tput sgr0)
readonly     RED=$(tput setaf 1)
readonly   GREEN=$(tput setaf 2)
readonly  YELLOW=$(tput setaf 3)
readonly    BLUE=$(tput setaf 4)
readonly MAGENTA=$(tput setaf 5)
readonly    CYAN=$(tput setaf 6)
readonly   WHITE=$(tput setaf 7)

# set name of the file that holds the path of the current fashcard
readonly CFCFILE=".flaca.cfc"

# set fix box names
readonly FIRSTBOX="box000"
readonly LASTBOX="boxEND"

# ------------------------------------------------------------------------------
# functions                                                            functions
# ------------------------------------------------------------------------------

# -------
# failmsg
# -------
#
# This function prints a red colored message via stderr.
#
function failmsg()
{
  # push to stderr
  echo -e "${RED}[FAIL]${NONE} $1" 1>&2
}

# -------
# warnmsg
# -------
#
# This function prints a yellow colored message via stderr.
#
function warnmsg()
{
  # push to stderr
  echo -e "${YELLOW}[WARN]${NONE} $1" 1>&2
}

# -------
# infomsg
# -------
#
# This function prints a blue colored message via stderr.
#
function infomsg()
{
  # push to stderr
  echo -e "${BLUE}[INFO]${NONE} $1" 1>&2
}

# -------
# donemsg
# -------
#
# This function prints a green colored message via stderr.
#
function donemsg()
{
  # push to stderr
  echo -e "${GREEN}[DONE]${NONE} $1" 1>&2
}

# -------
# get_box
# -------
#
# $1  flashcard path
#
function get_box()
{
  # get current box (last directory)
  sed -nre "s|.*(box[^/]{3})/[^/]+$|\1|p" <<< "$1"
}

# ------------
# get_next_box
# ------------
#
# $1  box123
#
function get_next_box()
{
  # last box given
  if [ "$1" == "$LASTBOX" ] ; then

    # stay in last box
    echo "$LASTBOX"

    # signalize success
    return 0

  fi

  # find next box (print without starting point)
  find -maxdepth  "1"              \
       -type      "d"              \
       -regextype "posix-extended" \
       -regex     ".+/box[^/]{3}$" \
       -printf    "%P\n"           \
  | sort                           \
  | sed --quiet                    \
        --regexp-extended          \
        --expression="

          # current box found
          /^$1/ {

            # read next line
            n

            # push to stdout
            /[^[:space:]]/ { p }

            # finish after first printed line
            q
          }
        "

  # signalize success
  return 0
}

# ---------------
# get_next_number
# ---------------
#
# $1  directory
#
function get_next_number()
{
  {
    # push dummy file to stdout
    echo "000000-dummy.pdf"

    # get pdf files from this directory (print last part only)
    find "$1"                                                \
         -maxdepth  "1"                                      \
         -type      "f"                                      \
         -regextype "posix-extended"                         \
         -regex     ".+/[[:digit:]]{6}-[^/]+\.[Pp][Dd][Ff]$" \
         -printf    "%f\n"
  }                                                          \
  | sort                                                     \
  | tail -n 1                                                \
  | sed -re "s/^0*([[:digit:]]+)-.*/\1 + 1/"                 \
  | bc
}

# ------------------------------------------------------------------------------
# commands                                                              commands
# ------------------------------------------------------------------------------

# check permission to write
if [ ! -w "$PWD" ] ; then

  # notify user
  failmsg "no permission to write here: \"$PWD\""

  # signalize trouble
  exit 1

fi

# check if first box is missing
if [ ! -d "$FIRSTBOX" ] ; then

  # notify user
  failmsg "unable to locate directory: \"$FIRSTBOX\""

  # signalize trouble
  exit 1

fi

# check if last box is missing
if [ ! -d "$LASTBOX" ] ; then

  # notify user
  failmsg "unable to locate directory: \"$LASTBOX\""

  # signalize trouble
  exit 1

fi

# check if 'current-flashcard' file is missing or empty
if [ ! -s "$CFCFILE" ] ; then

  # notify user
  failmsg "no flashcard specified"

  # signalize trouble
  exit 1

fi

# get path from 'current-flashcard' file
FLASHCARD=$(sed -nre "/^[[:space:]]*$/ { d } ; p ; q" "$CFCFILE")

# check given path
if [ ! -f "$FLASHCARD" ] ; then

  # notify user
  failmsg "unable to locate flashcard: \"$FLASHCARD\""

  # signalize trouble
  exit 1

fi

# get part of the filename to keep
FIXPART=$(basename "$FLASHCARD" | sed -re "s|^[[:digit:]]{6}-||")

# get current box
NOWBOX=$(get_box "$FLASHCARD")

# check box
if [ -z "$NOWBOX" ] ; then

  # notify user
  failmsg "unable to resolve current box: \"$FLASHCARD\""

  # signalize trouble
  exit 1

fi

# get second box
NEWBOX=$(get_next_box "$FIRSTBOX")

# only two boxes present
if [ "$NEWBOX" == "$LASTBOX" ] ; then

  # move flashcard to first box
  NEWBOX="$FIRSTBOX"

fi

# get next box index
NEWNUM=$(get_next_number "$NEWBOX")

# check index
if [ -z "$NEWNUM" ] ; then

  # notify user
  failmsg "unable to resolve box index: \"$NEWBOX\""

  # signalize trouble
  exit 1

fi

# create target path
TARGETPATH=$(printf "%s/%06d-%s" "$NEWBOX" "$NEWNUM" "$FIXPART")

# just to make sure
if [ -f "$TARGETPATH" ] ; then

  # notify user
  failmsg "target file already exists: \"$TARGETPATH\""

  # signalize trouble
  exit 1

fi

# move flashcard to next section
mv -f "$FLASHCARD" "$TARGETPATH" &>"/dev/null"

# check operation
if [ -f "$TARGETPATH" ] && [ ! -f "$FLASHCARD" ] ; then

  # reset file that holds the path of the current flashcard
  truncate -s 0 "$CFCFILE"

  # show progress
  donemsg "$FIXPART: $NEWBOX <-- $NOWBOX"

else

  # notify user
  failmsg "flashcard could not be moved: \"$FLASHCARD\""

  # signalize trouble
  exit 1

fi

# signalize success
exit 0

